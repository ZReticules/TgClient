proc_noprologue

importlib oleaut32,\
	SafeArrayAccessData,\
	SafeArrayUnaccessData,\
	SafeArrayGetLBound,\
	SafeArrayGetUBound,\
	SafeArrayCreate,\
	SafeArrayDestroy,\
	VariantClear

importlib kernel32,\
	GetFileAttributesW,\
	WritePrivateProfileStringW,\
	WritePrivateProfileStringA,\
	GetPrivateProfileStringW,\
	GetCurrentDirectoryW,\
	Sleep

proc TgClient.make c uses pbx, this, apiKey, fpLog
	@sarg @arg2
	virtObj .this TgClient at pbx from @arg1
	@larg pdx, @arg3
	; int3
	mov [.this.fpLog], pdx
	; pxor xmm0, xmm0
	; movq [.this.updates], xmm0
	mov [.this.__onMsg], NULL
	@call [CoCreateInstance](CLSID_ServerXMLHTTP60, NULL, CLSCTX.INPROC_SERVER, IID_IServerXMLHTTPRequest, addr .this.__httpObj)

	local size:DWORD
	@call [size] = [GetCurrentDirectoryW](0, NULL)

	@call .this.url->make(pax)
	with path:WString(pax)
		local lpVoid:POINTER

		@call path->fromWChars([apiKey], -1);->println()
		@call [lpVoid] = path->getLpWChars()
		mov eax, [path.len]
		@call [.this.apiKey] = CNV::alloc(addr pax * 2 + 2)
		mov eax, [path.len]
		@call CNV::fill([.this.apiKey], [lpVoid], addr pax * 2 + 2)
		@call .this.__comDict->make(0)


		@call [lpVoid] = path->getLpWChars()
		@call [path.len] = [GetCurrentDirectoryW]([size], pax)
		@call path->addWChar(+"\", 1)->addWChars([.this.apiKey], -1)->addWChars(L ".ini", 4)
		@call [lpVoid] = path->getLpWChars()
		@call path->findWChar(2, +":")
		mov pdx, [lpVoid]
		mov word[pdx + pax * 2], "_"
		mov eax, [path.len]
		@call [.this.__ini] = CNV::alloc(addr pax * 2 + 2)
		mov eax, [path.len]
		@call CNV::fill([.this.__ini], [lpVoid], addr pax * 2 + 2)

		@call [GetFileAttributesW]([.this.__ini])
		cmp pax, -1
		jne @f
			@call [WritePrivateProfileStringW](L "Main", L "updates", L "0", [.this.__ini])
		@@:

		@call path->realloc(23)->getLpWChars()
		@call [path.len] = [GetPrivateProfileStringW](L "Main", L "updates", NULL, pax, 23, [.this.__ini])
		@call [.this.updates] = path->parseInt(10)
		
		cmp [.this.fpLog], NULL
		je @f
			@call c [fprintf]([.this.fpLog], "Bot started.\nSaved updates id: %lld\n", [.this.updates])
		@@:
	end_with
	ret
endp

proc TgClient.call c uses pbx psi, this, method, name, body, size
	@sarg @arg2, @arg3, @arg4
	virtObj .this TgClient at pbx from @arg1
	virtObj .http IServerXMLHTTPRequest at psi from [.this.__httpObj]

	with url:WString(0)
		@call url->sprintf(const fwstr "https://api.telegram.org/bot%s/%s", [.this.apiKey], [name])->getLpWChars()
		@call .http->open([method], pax)
    	@call .http->setRequestHeader(L "Content-Type", L "application/json; charset=utf-8")
    	
    	switch [size]
    		case_default
    			local psa:POINTER, rgsabound:POINT, padata:POINTER
		    	inc [size]
		    	mov pax, [size]
		    	mov [rgsabound.x], eax
		    	mov [rgsabound.y], 0
		    	@call [psa] = [SafeArrayCreate](VT_UI1, 1, addr rgsabound)
		    	@call [SafeArrayAccessData]([psa], addr padata)
		    	@call CNV::fill([padata], [body], [size])
		    	@call [SafeArrayUnaccessData]([psa])
		    	@call .http->send(VT_ARRAY or VT_UI1, [psa])
		    	@call [SafeArrayDestroy]([psa])
		    	jmp end_case
		    case 0
		    	@call .http->send()
		end_switch
	end_with
	ret
endp

proc TgClient.update c uses pbx, this
	virtObj .this TgClient at pbx from @arg1
	with body:String(0)
		@call body->sprintf(const fstr '{"offset":%ld}', [.this.updates])->getLpChars()
		; int3
		@call .this->call(L "POST", L "getUpdates", pax, [body.len])

		local lastUpdateId:QWORD

		movq xmm0, [.this.updates]
		movq [lastUpdateId], xmm0

    	local pVoid:POINTER, status:POINTER, jsonText:VARIANT
    	local lBound:POINTER, uBound:POINTER

		; virtObj .http IServerXMLHTTPRequest at psi from [.this.__httpObj]
		; int3
	    @call [.this.__httpObj]->get_status(addr status)
	    cmp [status], 200
	    	jne break_with
	    @call [.this.__httpObj]->get_responseBody(addr jsonText)
	    @call [SafeArrayAccessData](pointer[jsonText.llVal], addr pVoid)
	    @call [SafeArrayGetLBound](pointer[jsonText.llVal], 1, addr lBound)
	    @call [SafeArrayGetUBound](pointer[jsonText.llVal], 1, addr uBound)
		try
			with < jnode:JSONNode(JSONTypes.bool, qword 1, 0, 0) >
				; @call c [puts]([pVoid])
			    mov pax, [uBound]
			    sub pax, [lBound]
			    inc pax
			    ; int3
				@call jnode->make(JSONTypes.parse_string, qword[pVoid], addr pax, 0)
				@call jnode->select("result", -1);->get("update_id", -1)
				; mov pax, [jnode.selectedNode]
				@call jnode->getLen()
				test pax, pax
					jz break_with
				pxor xmm0, xmm0
				movq [.this.updates], xmm0
				@call jnode->forEach(.json_callback, addr .this)
				
				; updates += 1
				pcmpeqq xmm1, xmm1
				movq xmm0, [.this.updates]
				psubq xmm0, xmm1
				movq [.this.updates], xmm0
				
				with wstr:WString(0)
					@call wstr->fromInt64([.this.updates], 10, 0)->getLpWChars()
					@call [WritePrivateProfileStringW](L "Main", L "updates", pax, [.this.__ini])
				end_with
			end_with
		catch
			@call Exception::getExceptionInfo()
			virtObj .e EXCEPTION_RECORD at pbx from pax
			mov pdx, [.e.ExceptionAddress]
			switch [.e.ExceptionCode]
				case_default
					cmp [.this.fpLog], NULL
					je @f
						@call c [fprintf]([.this.fpLog], \
							"Unknown exception at address %p! Code: %x\n", pdx, [.e.ExceptionCode])
					@@:
					@call [ExitProcess](0)
				case Exception.EXCEPTION_RETURN
					virtObj .je JSONException at .e.ExceptionInformation
					mov pdx, [.je.lpSmb]
					cmp [.this.fpLog], NULL
					je @f
						@call c [fprintf]([fprintf], "Unexpected character '%c' in codpoint at index %d in response:\n%s\n", byte[pdx], [.je.pointIndex], [pVoid])
					@@:
			end_switch
		end_try

	    @call [SafeArrayUnaccessData](pointer[jsonText.llVal])
	    @call [VariantClear](addr jsonText)
	    ; @call c [printf]("%lld\n", [.this.updates])
	end_with
    mov pax, [status]
	ret

	proc .json_callback c uses pbx psi, node, key, keyLen, lParam
		@sarg @arg4
		virtObj .node JSONNode at pbx from @arg1
		@call .node->get("update_id", 9, NULL)
		movq xmm1, [pax + JSONNode.value]

		virtObj .client TgClient at psi from [lParam]
		movq xmm0, [.client.updates]
		pcmpgtq xmm0, xmm1
		ptest xmm0, xmm0
		jnz @f
			movq [.client.updates], xmm1
		@@:
		cmp [.client.fpLog], NULL
		je @f
			@call .node->forEach(.json_callback_print, <va_list 0, [.client.fpLog]>)
			@call c [putc](0Ah, [.client.fpLog])
		@@:
		cmp [.client.__onEdit], NULL
		@block je @fb
			@call .node->get("edited_message", -1, NULL)
			test pax, pax
			@block jz @fb
				@call c [.client.__onEdit](addr .client, pax)
				jmp .return
			@endb
		@endb
		cmp [.client.__onMsg], NULL
		@block je @fb
			@call .node->select("message", 7)
			cmp eax, JSONRetCodes.success
			@block jne @fb
				@call c .check_commands([lParam], [.node.selectedNode])
				test eax, eax
					jnz .return
				; @call c .check_entities([lParam], [.node.selectedNode])
				@call c [.client.__onMsg](addr .client, [.node.selectedNode])
				jmp .return
			@endb
			; mov pcx, [lParam]
		@endb

		.return:
			@call .node->reset()
			mov eax, esp
			ret

		proc .json_callback_print c uses pbx, node, key, keyLen, lParam
			@sarg @arg1, @arg2, @arg3, @arg4
			
			local fpLog:POINTER

			mov ebx, dword[lParam]
			mov pax, [pbx + pointer.size]
			mov [fpLog], pax

			mov ebx, pointer[ebx]
			test ebx, ebx
			@block < jz @fb >
				@call c [putc](0x09, [fpLog])
				dec ebx
			@endb < jnz @sb >

			virtObj .node JSONNode at pbx from [node]
			cmp [keyLen], NULL
			je @f
				@call c [fprintf]([fpLog], "'%.*s': ", [keyLen], [key])
			@@:
			switch [.node.jType]
				case JSONTypes.bool
					cmp dword[.node.value], 0
					jne @f
						@call c [fputs]("false\n", [fpLog])
						jmp .return
					@@:
					@call c [fputs]("true\n", [fpLog])
					jmp .return
				case JSONTypes.null
					@call c [fputs]("null\n", [fpLog])
					jmp .return
				case JSONTypes.number
					@call c [fprintf]([fpLog], "%g\n", [.node.value])
					jmp .return
				case JSONTypes.integer
					@call c [fprintf]([fpLog], "%lld\n", [.node.value])
					jmp .return
				case JSONTypes.string
					@call c [fprintf]([fpLog], "'%.*s'\n", [.node.len], [.node.lpStr])
					jmp .return
				case JSONTypes.object
					@call c [fputs]("{\n", [fpLog])
					jmp end_case
				case JSONTypes.array
					@call c [fputs]("[\n", [fpLog])
			end_switch
			mov pax, [lParam]
			mov pax, pointer[pax]
			@call .node->forEach(.json_callback_print, <va_list addr pax + 1, [fpLog]>)
			
			mov ebx, dword[lParam]
			mov ebx, pointer[ebx]
			test ebx, ebx
			@block < jz @fb >
				@@:
					@call c [putc](0x09, [fpLog])
				dec ebx
				jnz @b
			@endb
			
			mov pbx, [node]
			
			switch [.node.jType]
				case JSONTypes.object
					@call c [fputs]("}\n", [fpLog])
					jmp .return
				case JSONTypes.array
					@call c [fputs]("]\n", [fpLog])
			end_switch
			
			.return: 
				mov eax, esp
				ret
		endp
			
		struct TgClient.UpdateCtx
			msg 		P_JSONNode
			comDict 	P_SimpleDict
			bot 		P_TgClient
			; entity 		P_JSONNode
			
			indexNow 	rptr 1
			indexEnd	rptr 1
			
			entityText 	rptr 1
			eOffset		rd 1
			entityLen	rd 1
			pointsCount	rd 1

			handled 	rd 1
		ends

		proc .check_commands c uses pbx psi, this, msg
			virtObj .this TgClient at psi from @arg1
			virtObj .msg JSONNode at pbx from @arg2

			local lpStr:POINTER, len:POINTER
			local entities:P_JSONNode
			
			local ctx:TgClient.UpdateCtx
			mov [ctx.handled], NULL

			; @call .msg->forEach(main.json_callback_print, 0)
			
			@call .msg->get("text", 4, NULL)
			test pax, pax
				jz .return

			mov pdx, [pax + JSONNode.lpStr]
			mov [lpStr], pdx
			mov edx, [pax + JSONNode.len]
			mov [len], pdx

			@call [entities] = .msg->get("entities", 8, NULL)
			cmp [entities], NULL
				je .return

			lea pax, [.msg]
			mov [ctx.msg], pax
			mov pax, [lpStr]
			mov [ctx.indexNow], pax
			add pax, [len]
			mov [ctx.indexEnd], pax
			mov [ctx.pointsCount], 0
			lea pax, [.this.__comDict]
			mov [ctx.comDict], pax
			lea pax, [.this]
			mov [ctx.bot], pax
			mov [ctx.entityText], NULL
			mov [ctx.handled], 0
			@call [entities]->forEach(.find_commands_callback, addr ctx)
			
			local p_callback:POINTER, cmdData:TgClient.CommandData
			
			@block 
				cmp [ctx.entityText], NULL
					je .return
				@call [ctx.comDict]->get([ctx.entityText], [ctx.entityLen], NULL)
				test pax, pax
					jnz @fb
				mov pax, [.this.__onUnkCmd]
				test pax, pax
					jz .return
			@endb

			mov [p_callback], pax
			
			; load command text start pointer
			mov pax, [ctx.entityText]
			mov [cmdData.pText], pax

			; load length of the text
			mov pax, [ctx.indexEnd]
			sub pax, [ctx.entityText]
			mov [cmdData.textLen], eax

			; load length of the command itself, like len("/command")
			mov eax, [ctx.entityLen]
			mov [cmdData.commandLen], eax
			
			; command handler call
			; @call c [printf]("%d : %.*s\n", [.ctx.entityLen], pax, [.ctx.entityText])
			@call c [p_callback]([ctx.bot], [ctx.msg], addr cmdData)
			@call [ctx.msg]->reset()
			mov [ctx.handled], esp

			.return: 
				mov eax, [ctx.handled]
				ret

			proc .find_commands_callback c uses pbx psi, node, key, keyLen, lParam
				@sarg @arg2, @arg3, @arg4
				virtObj .node JSONNode at pbx from @arg1
				virtObj .ctx TgClient.UpdateCtx at psi from @arg4
				@call c [printf]("command\n")
				
				local strLen:DWORD
				mov pax, [.ctx.indexEnd]
				sub pax, [.ctx.indexNow]
				mov [strLen], eax

				@call .node->get("type", 4, NULL)
				mov pax, [pax + JSONNode.lpStr]
				cmp dword[pax], "bot_"
					jne .continue

				@call .node->get("offset", 6, NULL)
				mov eax, dword[pax + JSONNode.value]
				mov [.ctx.eOffset], eax

				@call Utf8::iterate([.ctx.indexNow], [strLen], .iter_utf8_callback, addr .ctx)
				
				@call .node->get("length", 6, NULL)
				mov eax, dword[pax + JSONNode.value]
				mov [.ctx.entityLen], eax

				.continue:
					mov eax, 1
					ret

				proc .iter_utf8_callback c uses pbx, lpSmb, codepoint, lParam, lpCtx
					; int3
					@larg pax, @arg1
					virtObj .ctx TgClient.UpdateCtx at pbx from @arg3
					local pCnt:DWORD
					
					mov [.ctx.indexNow], pax
					
					mov ecx, 1
					cmp @arg2, 0xD7FF
					mov edx, 2
					cmova ecx, edx
					
					add ecx, [.ctx.pointsCount]
					xchg ecx, [.ctx.pointsCount]
					cmp ecx, [.ctx.eOffset]
					@block < jne @fb >
						xchg ecx, [.ctx.pointsCount]
						@block 
							cmp [.ctx.entityText], NULL
								je @fb
							@call [.ctx.comDict]->get([.ctx.entityText], [.ctx.entityLen], NULL)
							test pax, pax
								jz @fb

							local p_callback:POINTER, cmdData:TgClient.CommandData
							mov [p_callback], pax
				
							mov pax, [.ctx.entityText]
							mov [cmdData.pText], pax
							
							mov pax, [.ctx.indexNow]
							sub pax, [.ctx.entityText]
							mov [cmdData.textLen], eax

							mov eax, [.ctx.entityLen]
							mov [cmdData.commandLen], eax

							; command handler call
							; @call c [printf]("%d : %.*s\n", [.ctx.entityLen], pax, [.ctx.entityText])
							@call c [p_callback]([.ctx.bot], [.ctx.msg], addr cmdData)
							@call [.ctx.msg]->reset()
							mov [.ctx.handled], esp
						@endb
						mov pax, [.ctx.indexNow]
						mov [.ctx.entityText], pax
						mov eax, 0
					@endb
					ret
				endp
			endp
		endp
	endp
endp

proc TgClient.onCommand c, this, key, keyLen, callback, isConst
	virtObj .this TgClient at pcx from @arg1
	@call .this.__comDict->set(@arg2, @arg3, @arg4, [isConst])
	ret
endp

proc TgClient.reply c uses pbx psi pdi, this, messageJN, response, respLen, parseMode
	@sarg @arg3, @arg4
	virtObj .this TgClient at pbx from @arg1
	virtObj .msg JSONNode at psi from @arg2
	local msg_id:QWORD
	@call .msg->get("message_id", -1, NULL)
	movq xmm0, [pax + JSONNode.value]
	movq [msg_id], xmm0

	local chat_id:QWORD
	@call .msg->select("chat", 4)->get("id", 2, NULL)
	movq xmm0, [pax + JSONNode.value]
	movq [chat_id], xmm0
	with body:String(0)
		.fmt_parse_mode @const fstr '{"chat_id":%ld,"reply_to_message_id":%ld,"allow_sending_without_reply":true,"text":"%.*s","parse_mode":"%s"}'
		.fmt_no_parse_mode @const fstr '{"chat_id":%ld,"reply_to_message_id":%ld,"allow_sending_without_reply":true,"text":"%.*s"}'
		
		mov pdx, .fmt_parse_mode
		cmp [parseMode], NULL
		jne @f
			mov pdx, .fmt_no_parse_mode
		@@:
		@call body->sprintf(pdx, [chat_id], [msg_id], [respLen], [response], [parseMode])->getLpChars()
		@call .this->call(L "POST", L "sendMessage", pax, [body.len])
	end_with
	@call .msg->reset()
	ret
endp

proc TgClient.onMessage c, this, callback
	virtObj .this TgClient at pcx from @arg1
	@larg pdx, @arg2
	mov [.this.__onMsg], pdx
	ret
endp

proc TgClient.onEdit c, this, callback
	virtObj .this TgClient at pcx from @arg1
	@larg pdx, @arg2
	mov [.this.__onEdit], pdx
	ret
endp

proc TgClient.onUnknownCommand c, this, callback
	virtObj .this TgClient at pcx from @arg1
	@larg pdx, @arg2
	mov [.this.__onUnkCmd], pdx
	ret
endp

proc TgClient.send c uses pbx psi pdi, this, chatId:QWORD, message, msgLen, parseMode
	@sarg @arg2, @arg3, @arg4
	virtObj .this TgClient at pbx from @arg1
	with body:String(0)

		.fmt_parse_mode @const fstr '{"chat_id":%ld,"text":"%.*s","parse_mode":"%s"}'
		.fmt_no_parse_mode @const fstr '{"chat_id":%ld,"text":"%.*s"}'
		mov pdx, .fmt_parse_mode
		cmp [parseMode], NULL
		jne @f
			mov pdx, .fmt_no_parse_mode
		@@:
		@call body->sprintf(pdx, [chatId], [msgLen], [message], [parseMode])->getLpChars()
		@call .this->call(L "POST", L "sendMessage", pax, [body.len])
	end_with
	ret
endp

proc TgClient.start c uses pbx, this
	virtObj .this TgClient at pbx from @arg1
	@block
		@call .this->update()
		xor edx, edx
		cmp eax, 404
		jne @f
			@call c [printf]("Request status %d\n", pax)
			ret
		@@:
		cmp eax, 200
		je @f

			@call c [printf]("Request status %d\n", pax)
			mov edx, 5000
		@@:
		@call [Sleep](pdx)
	@endb < jmp @sb >
	.unauthorized:
endp

proc TgClient.unmake c uses pbx, this
	virtObj .this TgClient at pbx from @arg1
	@call CNV::free([.this.apiKey])
	@call CNV::free([.this.__ini])
	virtObj .http IServerXMLHTTPRequest at pbx from [.this.__httpObj]
	@call .http->Release()
	@call .this.__comDict->unmake()
	ret
endp

proc_resprologue
